package org.firstinspires.ftc.teamcode.Old_Swerve;import com.qualcomm.hardware.bosch.BNO055IMU;import com.qualcomm.robotcore.eventloop.opmode.LinearOpMode;import com.qualcomm.robotcore.eventloop.opmode.TeleOp;import com.qualcomm.robotcore.hardware.AnalogInput;import com.qualcomm.robotcore.hardware.DcMotor;import com.qualcomm.robotcore.hardware.Servo;import com.qualcomm.robotcore.util.ElapsedTime;import org.firstinspires.ftc.robotcore.external.navigation.Acceleration;import org.firstinspires.ftc.robotcore.external.navigation.AngleUnit;import org.firstinspires.ftc.robotcore.external.navigation.AxesOrder;import org.firstinspires.ftc.robotcore.external.navigation.AxesReference;import org.firstinspires.ftc.robotcore.external.navigation.Orientation;import org.firstinspires.ftc.robotcore.external.navigation.Position;import org.firstinspires.ftc.robotcore.external.navigation.Velocity;import org.firstinspires.ftc.teamcode.General.Vuforia.FTCVuforia;import static java.lang.Math.cos;import static java.lang.Math.sin;@TeleOp(name="SwerveLinearBase", group="Swerve")//@Disabledpublic class SwerveLinearBase extends LinearOpMode {    /* Declare OpMode members. */    HardwareSwerveV1 robot           = new HardwareSwerveV1();   // Use the SwerveV1 hardware file    FTCVuforia vuforia;    public DcMotor  DMotor1; //Driver Motor Front (1)    public DcMotor  DMotor2; //Driver Motor Back (2)    public DcMotor  PMotor1; //Passenger Motor Front (1)    public DcMotor  PMotor2; //Passenger Motor Back (2)    //Swerve Drivebase Servos    public Servo    DServo1; //Driver ServoFront (1)    public Servo    DServo2; //Driver ServoFront (2)    public Servo    PServo1; //Passenger ServoFront (1)    public Servo    PServo2; //Passenger ServoFront (2)    //Swerve Drivebase Encoders    public AnalogInput DSensor1; //Driver Sensor Front (1)    public AnalogInput  DSensor2; //Driver Sensor Back (2)    public AnalogInput  PSensor1; //Passenger Sensor Front (1)    public AnalogInput  PSensor2; //Passenger Sensor Back (2)    public BNO055IMU imu;    Orientation angles;    Acceleration gravity;    //public boolean turnEfficiency = false;    public double driveDirection;    public double powerOut;    private ElapsedTime runtime = new ElapsedTime();    static final double     COUNTS_PER_MOTOR_REV    = 1440 ;    // eg: TETRIX Motor Encoder    static final double     DRIVE_GEAR_RATIO        = 2.66 ;         // This is < 1.0 if geared UP    static final double     WHEEL_DIAMETER_INCHES   = 4.0 ;     // For figuring circumference    static final double     COUNTS_PER_INCH         = (COUNTS_PER_MOTOR_REV * DRIVE_GEAR_RATIO) /            (WHEEL_DIAMETER_INCHES * 3.1415);    //PID Variable    int integral = 0;    double u;    int error;    int previousError = 0;    int setPoint;    double PIDpower;    double angle;    int angleError;    int targetOp;    int target;    int angleErrorOp;    int measuredAngle;    @Override    public void runOpMode() {        /* Initialize the hardware variables.         * The init() method of the hardware class does all the work here         */        robot.init(hardwareMap);        // Wait for the game to start (driver presses PLAY)        waitForStart();        vuforia = new FTCVuforia();        imu.startAccelerationIntegration(new Position(), new Velocity(), 1000);        DMotor1.setDirection(DcMotor.Direction.REVERSE);        DMotor2.setDirection(DcMotor.Direction.REVERSE);        DMotor1.setMode(DcMotor.RunMode.RUN_USING_ENCODER);        DMotor2.setMode(DcMotor.RunMode.RUN_USING_ENCODER);        PMotor1.setMode(DcMotor.RunMode.RUN_USING_ENCODER);        PMotor2.setMode(DcMotor.RunMode.RUN_USING_ENCODER);        DMotor1.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.BRAKE);        DMotor2.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.BRAKE);        PMotor1.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.BRAKE);        PMotor2.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.BRAKE);        // run until the end of the match (driver presses STOP)        while (opModeIsActive()) {            gamepad1.setJoystickDeadzone(.1F); //Set joystick deadzone to a lower number            double leftX = -gamepad1.left_stick_x;            double leftY = gamepad1.left_stick_y;            double rightX = -gamepad1.right_stick_x;            SwerveDriveRobotCentricV2(leftX,leftY,rightX,true);            angles   = imu.getAngularOrientation(AxesReference.INTRINSIC, AxesOrder.ZYX, AngleUnit.DEGREES);            gravity  = imu.getGravity();            // Pause for metronome tick.  40 mS each cycle = update 25 times a second.            robot.waitForTick(40);        }    }    public void SwerveDriveRobotCentricV2 (double x1, double y1, double x2, boolean turnEfficiency) {        //this mode is designed for module turn efficiency        final double L = 13.25; //length between axles        final double W = 15.5; //width between axles        double r = (Math.sqrt ((L * L) + (W * W)))/2;        double a = x1 - x2 * (L / r);        double b = x1 + x2 * (L / r);        double c = y1 - x2 * (W / r);        double d = y1 + x2 * (W / r);        double backRightSpeed = Math.sqrt ((a * a) + (d * d));        double backLeftSpeed = Math.sqrt ((a * a) + (c * c));        double frontRightSpeed = Math.sqrt ((b * b) + (d * d));        double frontLeftSpeed = Math.sqrt ((b * b) + (c * c));        double backRightAngle = Math.atan2 (a, d) / Math.PI * 180 - 180;        double backLeftAngle = Math.atan2 (a, c) / Math.PI * 180 - 180;        double frontRightAngle = Math.atan2 (b, d) / Math.PI * 180 + 180;        double frontLeftAngle = Math.atan2 (b, c) / Math.PI * 180 + 180;        //test        Double DSe1 = DSensor1.getVoltage(); //Get voltage of Driver Front(1) encoder        Double DSe2 = DSensor2.getVoltage(); //Get voltage of Driver Back(2) encoder        Double PSe1 = PSensor1.getVoltage(); //Get voltage of Pass Front(1) encoder        Double PSe2 = PSensor2.getVoltage(); //Get voltage of Pass Back(2) encoder        DServo1.setPosition(SwivelPIDV2(DSe1,frontLeftAngle,.391,2.06,turnEfficiency)); //Rotate the module to position        //telemetry.addData("Front Left Error",driveDirection + "Speed: " + frontLeftSpeed);        telemetry.addData("Power",(driveDirection*frontLeftSpeed));        DMotor1.setPower(driveDirection*frontLeftSpeed);   //Set speed of Driver Motor Front(1) to front left        telemetry.addData("Motor:", DMotor1.getPower());        PServo1.setPosition(SwivelPIDV2(PSe1,frontRightAngle,1.503,2.06,turnEfficiency)); //Rotate the module to position        //telemetry.addData("Front Right Error",driveDirection + "Speed: " + frontRightSpeed);        telemetry.addData("Power",(driveDirection*frontRightSpeed));        PMotor1.setPower(driveDirection*frontRightSpeed);   //Set speed of Pass Motor Front(1) to front right        telemetry.addData("Motor:", PMotor1.getPower());        DServo2.setPosition(SwivelPIDV2(DSe2,backLeftAngle,1.542,2.06,turnEfficiency)); //Rotate the module to position        //telemetry.addData("Back Left Error",driveDirection + "Speed: " + backLeftSpeed);        telemetry.addData("Power",(driveDirection*backLeftSpeed));        DMotor2.setPower(driveDirection*backLeftSpeed);    //Set speed of Driver Motor Back(2) to back left        telemetry.addData("Motor:", DMotor2.getPower());        PServo2.setPosition(SwivelPIDV2(PSe2,backRightAngle,.025,2.06,turnEfficiency)); //Rotate the module to position        //telemetry.addData("Back Right Error",driveDirection + "Speed: " + backRightSpeed);        telemetry.addData("Power",(driveDirection*backRightSpeed));        PMotor2.setPower(driveDirection*backRightSpeed);    //Set speed of Pass Motor Back(2) to back right        telemetry.addData("Motor:", PMotor2.getPower());        telemetry.addData("FrontLeftAngle", frontLeftAngle);        telemetry.addData("FrontRightAngle", frontRightAngle);        telemetry.addData("BackLeftAngle", backLeftAngle);        telemetry.addData("BackRightAngle", backRightAngle);    }    public double SwivelPIDV2 (double voltage, double targetAngle, double zeroPosVolt, double maxVolt, boolean turnEfficiency) {        final double Kp = .02; //.02        final double Ki = 0;        final double Kd = .008;        int dt = 20;        int targetValue; //180//        targetValue = (int)targetAngle;        angle = ((voltage-zeroPosVolt)/maxVolt)*360;        if (angle<0) {            angle = 360+angle;        } else {            //        }        //getting the angle from the encoder by dividing voltage by 360        measuredAngle = (int)angle;        //calculate the angle with 180 degrees difference to see if it's faster than turning all the way around        target = (int)targetAngle;        targetOp = (target+180)%360;        angleError = (target - measuredAngle);        angleError -= (360*Math.floor(0.5+((angleError+0d)/360.0)));        angleErrorOp = (targetOp - measuredAngle);        angleErrorOp -= (360*Math.floor(0.5+((angleErrorOp+0d)/360.0)));        if (turnEfficiency) {            if (Math.abs(angleError)>Math.abs(angleErrorOp)) {                targetValue=targetOp;                driveDirection=-1;            } else {                targetValue=target;                driveDirection=1;            }        } else {            targetValue=target;            driveDirection = 1;        }        angleError = (targetValue - measuredAngle);        angleError -= (360*Math.floor(0.5+((angleError+0d)/360.0)));        error = angleError;        //ethan's version/*        int currentAngle = measuredAngle;        boolean shouldReverseMotors = false;        int targetAngle1 = (int)targetAngle;        int targetWeird = 180+targetAngle1;        int distance1 = Math.abs(targetAngle1-currentAngle);        int distance2 = Math.abs(targetWeird-currentAngle);        if(distance1 > distance2){            //do things normally        } else {            targetAngle1 = 180+targetAngle1;            shouldReverseMotors = true;        }        driveDirection = shouldReverseMotors ? -1 : 1;        angleError = (targetAngle1 - measuredAngle);        angleError -= (360*Math.floor(0.5+((angleError+0d)/360.0)));        error = angleError;*/        integral += Ki * error * dt;        u = (Kp * error + integral + Kd * (error - previousError) / dt);        previousError = error;        PIDpower = -1*u;        if (PIDpower>0) {            powerOut = .5+(PIDpower/2);        } else if (PIDpower<0) {            powerOut = .5+(PIDpower/2);        } else {            powerOut = PIDpower;        }        return powerOut;    }    public void SwerveDriveFieldCentricV1 (double x1, double y1, double x2) {        double rcw = x2;        double forwrd = y1 * -1; /* Invert stick Y axis */        double strafe = x1;/* Adjust Joystick X/Y inputs by navX MXP yaw angle */        double gyro_degrees = angles.firstAngle;        double gyro_radians = gyro_degrees * Math.PI/180;        double temp = forwrd * cos(gyro_radians) +                strafe * sin(gyro_radians);        strafe = -forwrd * sin(gyro_radians) +                strafe * cos(gyro_radians);        forwrd = temp;//At this point, Joystick X/Y (strafe/forwrd) vectors have been//rotated by the gyro angle, and can be sent to drive system//        SwerveDriveRobotCentricV2(forwrd,strafe,rcw,true);    }    public void autonomousRobotCentricGyroEncoder (double targetDistance, double speed) {        double previousEncoderAvg = (DMotor1.getCurrentPosition() + DMotor2.getCurrentPosition() +                PMotor1.getCurrentPosition() + PMotor2.getCurrentPosition())/4;        double currentEncoderAvg = previousEncoderAvg;        double startAngle = angles.firstAngle;        while (currentEncoderAvg<(previousEncoderAvg+(targetDistance*COUNTS_PER_INCH))) {            currentEncoderAvg = (DMotor1.getCurrentPosition() + DMotor2.getCurrentPosition() +                    PMotor1.getCurrentPosition() + PMotor2.getCurrentPosition())/4;            double angleOffset = angles.firstAngle-startAngle;            SwerveDriveRobotCentricV2(angleOffset,speed,0,false);        }        DMotor1.setPower(0);        DMotor2.setPower(0);        PMotor1.setPower(0);        PMotor2.setPower(0);    }    public void autonomousFieldCentricEncoder (double y1, double x1, double x2, double targetDistance) {        double previousEncoderAvg = (DMotor1.getCurrentPosition() + DMotor2.getCurrentPosition() +                PMotor1.getCurrentPosition() + PMotor2.getCurrentPosition())/4;        double currentEncoderAvg = previousEncoderAvg;        while (currentEncoderAvg<(previousEncoderAvg+(targetDistance*COUNTS_PER_INCH))) {            currentEncoderAvg = (DMotor1.getCurrentPosition() + DMotor2.getCurrentPosition() +                    PMotor1.getCurrentPosition() + PMotor2.getCurrentPosition())/4;            SwerveDriveFieldCentricV1(x1,y1,x2);        }        DMotor1.setPower(0);        DMotor2.setPower(0);        PMotor1.setPower(0);        PMotor2.setPower(0);    }    public double vuforiaPID (double angleOffset, int targetAngle) {        final double Kp = .02;        final double Ki = 0;        final double Kd = .008;        int targetValue = 0; //180        int dt = 20;        targetValue = targetAngle;        angle = angleOffset;        setPoint = (int) angle;        error = targetValue - setPoint;        integral += Ki * error * dt;        if(integral > targetValue * 0.25) {            integral = (int) (targetValue * 0.25);        }        u = (Kp * error + integral + Kd * (error - previousError) / dt);        previousError = error;        PIDpower = -1*u;        if (PIDpower>0) {            powerOut = .5+(PIDpower/2);        } else if (PIDpower<0) {            powerOut = .5+(PIDpower/2);        } else {            powerOut = PIDpower;        }        return powerOut;    }    public double floor(double n) {        return (n - (n % 1));    }    public void vuforiaDrive (double ySpeed, double xSpeed, double target, double yOffset) {        while (vuforia.getY(target)>yOffset) {        }    }}